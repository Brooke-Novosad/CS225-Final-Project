Eunice Leung - efleung2
Brooke Novosad - novosad3
Serena Trika - trika2
Jordan Whalen - jwhalen4
December 12th, 2021
CS 225

CS 225 Final Results
Our goal for this project was to help people travel efficiently in Pennsylvania. We found shortest paths across PA to allow for efficient travel and faster commutes using Dijkstra’s algorithm. We also created a Tour Finder tool to find interesting road tours throughout the state, helping people explore PA and visit as many different places as possible. Additionally, we also implemented a BFS traversal of the roadmap. The dataset of PA that we used consists of around 1 million nodes, which represent intersections, and 1.5 million edges, which represent roads. Initially we believed that the graph was connected, but later through working on the traversal of the graph, we found it was disconnected. We also discovered that some intersections do not have cycles connected with them, but those that did produced extremely large tours. 

BFS was the graph traversal that we implemented. The reason for using this algorithm is to traverse all the nodes of the graph as well as its edges. There were two BFS methods that we implemented. The first being a regular graph traversal with no starting node input and default starting at node 0 of the graph. The BFS traversal runs until all of the nodes in the graph have been visited and accounts for disconnected portions of the graph. The second implementation allowed there to be a starting node, this could be useful for someone who wanted to generate different traversals of the same graph from different nodes. We also implemented a BFS helper method to help with our implementation that ensures that the nodes that were not connected would still be visited. Before adding the helper method there was an issue with not all of the nodes being visited during the graph traversal. 

Dijkstra’s Algorithm is the second deliverable. This algorithm finds the shortest path between 2 nodes. There are 2 runs of this algorithm in output.txt. The first one is with the nodes 2 and 15. The second is with 2 nodes that the user types into the terminal. This allows for the user to pick their own starting and ending point if they have a specific place they want to go to. There is also a chance that the 2 nodes are not connected since we found our graph to be disconnected. If this is the case, there will be a message printed to the terminal saying there is no path between these 2 nodes and the distance between them is infinity. We found this algorithm to be pretty straight forward, using the pseudo code from class. We did have an issue where we were adding nodes to the queue twice but after debugging we fixed this issue. 

Given a root node, Tour Finder finds a long cycle starting and ending at the root. We implemented this helpful tool by first creating a DFS tree of the whole graph and finding the deepest back edge connected to the root. The Tour Finder returns a vector of nodes in which to travel in the cycle. While not guaranteed to be the longest tour, it is one of the longer and more interesting ones because we keep track of how far each back edge is to the root and pick the deepest one. The user can pick a node to start their tour at and a long tour of locations to visit in PA will be printed out by their node ID’s. In cases where there is no tour, an empty list is printed. Our initial goal to find cycles in this project was to implement one of the Eulerian cycle algorithms. However, to find a Euler cycle, all nodes must have an even degree, which does not work for our graph. Finding cycles in a graph proved to be a complex goal, but we found that using DFS and back edges which we learned in class would help figure out an interesting cycle.

The return statements from the full run of main.cpp are saved in output.txt. The first 2 things printed are the BFS runs. The first one is the traversal starting at 0. The second is the traversal starting at the user input. The next thing in the file is Dijkstra’s shortest path. The first one is the shortest path between 2 and 15 and the next is the shortest path between 2 nodes that the user specifies. The last thing in the file is the Tour Finder. The first one is a tour starting at 5 and the second is a tour starting at a user specified node.  
